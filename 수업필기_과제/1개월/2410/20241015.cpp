#include <iostream>

using namespace std;

// 동적 할당

int main()
{

	// 메인 메모리 중 heap 영역을 사용. 런타임 중에 할당함

	// 1. 포인터 없이 heap영역에 접근할 수 없다.
	// 	ㄴ heap영역에는 변수의 이름을 붙일 수 없다 !! 오직 주소만!!
	//	ㄴ void* : 암튼 포인터인디 무슨 자료형인지 모르겠어요.
	// 		ㄴ 주소를 이용해 실제 메모리 공간에 접근하려 할 때는 명시적 형변환을 해줘야함.
	// 2. 메모리 반환을 반드시 해야 누수가 생기지 않는다. 내 메모리 줄줄 샌다..
	// 3. 니가 알아서 언제 할당하고 반환할 지를 판단해야 한다. 동적할당 이후부터 모든 문제는 내 책임이다.


	// c 언어 시절의 동적 할당 (어차피 존나 쓰셨죠? 그만씁시다...)
	// malloc(size_t size), calloc(size_t count, size_t size)
	// 말록은 말록, 칼록은 사이즈 추가(배열갯수라던지), 0으로 초기화도 해줌
	// free(void* pointer)
	// free 하면서 그 포인터를 NULL로 무 조 건 초기화 같이 해줘야함!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	// 함수
	// {
	// 	char* tmp = (char*)malloc(sizeof(char));
	// }
	//  ㄴ여기서 tmp가 힙메모리인 것은 아님
	//	 당연함 tmp라는 주소를 담는 포인터 변수! 는 스택메모리니까. 주소를담는포인터변수에게도주소가있다.
	//   대신 (char*)malloc(sizeof(char)) 가 주는 주소는 힙메모리에 있음.
	//   실제 주소. 와 주소를 담는 변수.는 구분해서 생각!!
	// 	 heap메모리는 할당 하고 프로그래머가 만든 포인터 변수에 담아서 사용할 수 밖에 없음

	

	// c++의 동적 할당
	// new 연산자
	int *p = new int;		// 동적할당기본
	int *a = new int(0);	// 동적 할당 및 초기화
	int *b = new int[4];	// 동적 배열(대괄호 안에 변수 가능)
	int input(10);			// 당연히 input을 cin으로 받아서 쓸 수도 있음
	int *c = new int[input] {10, 20, 30}; // 동적 배열 초기화 가능 //안디ㅗ잖아 //c++11이상가능(flag필요..)
	char *sName = new char[20] {'a','b','c'};

	cout << sName<<endl;

	// delete 연산자
	delete p;			// 메모리 반환
	delete a;
	delete[] b, c;		// 동적 배열의 메모리 반환. delete뒤에 대괄호를 붙여줘서 컴파일러에게 알림



	// 메모리 함수 (니 libft에 있는거..)
	// memset, memcpy, memmove, memchr, memcmp....
	// 암튼내가다만들음.이런썅

	return 0;
}


// 숙제 text RPG...


	// "직업을 선택하세요(1. 전사 2. 마법사 3. 도적) :"

	// ===
	// 이름: 직업
	// 체력:   공격력:  
	// 1. 사냥터 2. 종료:

	// 동일
	// 1. 초급 중급 고급 전단계

	// ===이랑
	// 이름직업
	// 체력공격력 계속유지
	// ===
	// 이름 : 초급
	// 체력: 공격력:
	// 1.공격 2.도망

	// 다잡으면 윗 상태(6줄)에서 승리
	// 계속하려면....아이썅리눅스

	// 승리 후 패배 후 다시 난이도 설정