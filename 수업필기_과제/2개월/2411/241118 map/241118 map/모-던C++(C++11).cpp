#include "pch.h"

// 모던하다모던해

int main()
{
	// auto 키워드 : 컴파일러가 자료형을 추론해 너어쥼
	// 당연히 값을 초기화 할 때 자료형을 추론하기 때문에 선언과 초기화가 동시에 이루어져야 함
	auto a = 10; // int

	map<int, int> map;

	auto iter = map.begin(); // map<int, int>::iterator 너무편리하구나...

	// 너무너무 편하고 좋아서 다들 막 쓰는데 좋은건 아니긴 함(직관성이 없으니까)


	////////////////////////////////////////////////////////////

	// 범위 기반 for문

	int arr[5] = { 0, };

	for (int i : arr)
	{
		cout << arr[i] << endl;
	}

	vector<int> vectemp;

	vectemp.push_back(10);
	vectemp.push_back(10);
	vectemp.push_back(10);
	vectemp.push_back(10);

	for (auto i : vectemp)
		cout << i << endl;
	// 포끼야아아아악!!!!!

	////////////////////////////////////////////////////////

	// 유니폼 초기화

	int i[3] = { 1,2,3 };
	int j[3]{ 1,2,3 }; // 등호 빼고 중괄호로 초기화 할 수 있게 해주는 문법
	
	// 구조체 멤버변수 초기화라던지...
	// 임시객체반환시 return {10, 20} 처럼 쓴다던지...

	////////////////////////////////////////////////////////

	// std::array : 기존 배열을 객체화 시킴
	// 생성자, 소멸자, 복사생성자, 대입연산자 지원
	// 당연하지만 정적배열기반 컨테이너

	// 배열 간 복사를 등호 하나로?!

	// 멤버함수에 추가하기 삭제하기가 업슴 
	// .data() 배열의 첫번째 주소 반환(이거 무슨 컨테이너도 있지 않았나)(벡터였네요)
	// .fill() 모든 원소 값을 통일시키기

	////////////////////////////////////////////////////////
	
	// 람다 표현식(lambda) : 무명(익명)의 인라인 함수
	// 함수 객체의 단점을 극복
	// 
	// 대-소-중괄호 순서
	// [] : '람다 소개자', '캡처절'. 컴파일러가 람다식임을 인지할 수 있게 하는 도구(이제부터람다식시작)
	// () : '파라미터 지정자' 매개변수 넣는 곳
	// {} : '람다 몸체', 그냥 함수 몸체.

	// ex)  [](int n) { cout << n << endl; }

	// 람다 함수는 이름이 없음. 오버로딩의 조건은 이름!이 같은 함수가 어쩌구저쩌구의 조건일때.. 이므로 람다함수는 오버로딩이 불가

	// 반환값을 적지 않아도 묵시적 반환으로 자료형을 정해 반환해줌
	// 명시적으로 할 수도 있음. ( ->자료형 )
	// ex)  [](int n)->int {return n + 3;}

	// 대괄호가 캡처절인 이유..
	// 함수에 외부의 데이터를 캡쳐해 들고 갈 수 있기 때문
	// ex)  [&](int n){ /***/}
	// 대괄호에 넣을 수 있는 캡처 옵션이 많으므로 수업 자료를 참고
	// [&], [=] ....


	return 0;
}