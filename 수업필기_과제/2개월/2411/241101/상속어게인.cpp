#include <iostream>

// UML기호찾아보기
// 상속성에 관한 내용 아이패드
// 오버라이딩 오버로딩
// 오버라이딩은 클래스의 문법 오버로딩은 함수의 문법

using namespace std;

// CDerived::CDerived(int _a) : CBase(a)


// 상속성

// 1. is-a
// 2. has-a




// 정적 바인딩(static binding) : 컴파일 타임 때 함수가 이미 바인드 되었다는 뜻
// 컴파일 때 생성 시점에서 이미 어떤 함수가 호출 될 지 정해져있다
// 동적할당 시점의 클래스가 뭐였던간에 자료형을 기준으로 사용 권한을 부여받음
// (당연히 자식포인터에 부모 동적할당은 안된다)

// 다형성을 쓰자
// 부모 자료형으로 자식 자료형의 기능을 좀 씁시다 그래야 상속도 ㅇㅈ이고 다형성도 ㅇㅈ이니까
// 1. 오버라이딩 : 상속 받는 자식들이 공통적으로 사용할 만한 함수 호출
// 2. 다운 캐스팅 : 상속 받는 자식들이 개별적인 기능을 사용할 때

// 오버라이딩의 조건
// 1. 클래스가 상속관계여햐함
// 2. 부모 자식 클래스가 형태가 완벽히 일치하는 함수가 둘 다 만들어져 있어야함.
// 	  반환타입 이름 매개변수 모 두 
// 3. 부모 클래스 함수 앞에 virtual 키워드가 붙어 있어야 함.
//    virtual!!! virtual!!! virtual!!! 
// => 동적바인딩

// virtual 이 붙은 함수 = "가상함수"
// 기본적으로 멤버 함수는 용량 취급하지 않음
// 함수만있는 클래스 크기 = 1
// 가상함수로 선언하면 vptr(가상함수포인터)가 생성?되어 8바이트가 잡히게 됨(64bit)
// vptr, vtbl
// 컴파일 타임에 virtual을 발견하면 가상함수 테이블이라는 것이 생성되고 거기에 내가 선언한 가상함수가 들어가게 됨
// 가상함수테이블은 code영역에 생기기 때문에 가상함수포인터 를 통하지 않으면 함수에 접근할 수 없게 됨
// 정리 : 가상함수로 선언할 시 함수가 아니라 내부적으로 가상함수포인터로 대체되어 저장되고
// 그래서 함수가 아닌 포인터가 포함된 것으로 계산되어 용량이 8바이트가 되고
// 부모에게 virtual이 붙어있는 함수는 자식의 동일 함수에도 virtual이 안보여도 상속되게 됨
// 자식도 자식나름의 가상함수포인터와 가상테이블이 생기게 된다 부모의 것을 받아 공유하는게 아니라
// 만약 가상함수포인터와 가상테이블이 부모의 것도 같이 받아왔다면 자식의 용량은 8이 아닌 16이 됐을 것
// 그래서 자식::함수가 가상테이블에 올라가며 부모의 동일 함수는 재정의되고 은닉되게 됨.(오버라이딩)
// 동적바인딩은 결론적으로 함수를 호출받았을 때 런타임 중에 논리적으로 판단해 자식것인지 부모것인지 골라가게 되기 때문에 동적이라 불림
// 정적바인딩이었다면 부모자료형으로 선언한 이상 동적할당이든뭐든 자식걸 암만 불러도 컴파일타임에 부모자료형?그럼부모함수. 라고 결정해 쓰는 것
// 동적바인딩은 부모자료형으로 선언했다 하더라도 자식객체를 담고있다면 가상테이블을 참조해 자식함수를 그때 골라 사용함

// 자식에게 부모가 가진 가상함수가 따로 오버라이딩 되어있지 않더라도 자식은 부모의 가상함수포인터를 상속받는다
// 별개의 가상테이블...........이어도 가상함수포인터는 동일 함수 일 때 '은닉'되어 안보인다는거지 안받는다는아님

// 디버깅 중에 가상함수테이블을 구경할 수 있음 

// 아 주석 진짜 개 뚱뚱하다 너무 끔찍하다..................

// 오버라이딩은 사실상 엄청나게 단점이 맞음(용량도 늘어나 시간도 늘어나 뭐가 좋음)
// 그런데 그걸 버리더라도 재정의라는 기능이 너무너무너무너무너무너무너무너무너무너무너무너무편해서 씀






// 자식 클래스가 부모 클래스를 상속 받을 때 
// private라고 상속을 안받는건아님;;;
// 다 받는데 그냥 못 쓸 뿐
// 그래서 부모가 Private에 가상함수를 만들어두면
// 자식은 못써도 vptr자체는 받긴해서 8바이트를 그대로 내려받는다
// 아~ 이건 진짜몰랐다 뇌아프다

int main()
{
	
	return 0;
}
