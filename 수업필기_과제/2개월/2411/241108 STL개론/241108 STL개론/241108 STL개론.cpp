#include "pch.h"
#include <iostream>
#include <algorithm>

// 자료구조 :  컴퓨터 프로그램을 구현하기 위해 연구 된 것
// 자료를 처리하기 위한 명령의 집합을 구성해 효율적으로 저장 및 탐색

// 당연히 메모리 절약과 수행시간 최소화가 목적


// 알고리즘 : 컴퓨터 명령 자체의 효율성을 증가시키기 위한 절차(혹은 방법)

///////////

// 알고리즘의 표현 방식
// 자연어, 순서도, 의사코드, 프로그래밍 언어
// 자연어는 우리 말, 순서도는 그림도식화, 의사코드는 특정 플밍언어가 아닌 가상의 언어로 코드 표현, 플밍언어는 플밍언어.

///////////

// 알고리즘 성능 분석
// 1. 공간 복잡도 : 알고리즘 실행에 필요한 저장 공간에 따른 성능 평가
// 2. 시간 복잡도 : 실행 시간이 얼마나 걸리는지에 따른 성능 평가
//	2.1. 오메가 표기법 : 젤 좋은 것 기준으로 평가
//	2.2. 빅오 표기법 : 젤 나쁜 것 기준으로 평가(O(n^2))
//	2.3. 세타 표기법 : 평균을 기준으로 평가


//////////////////////////////////////////////


// STL : Standard Template Library
//		 템플릿을 기반으로 하는 클래스 템플릿의 집합 라이브러리
//	C++에서 제공하는 라이브러리의 일종. 프로그래밍에 필요한 자료구조 + 알고리즘을 템플릿화 해서 제공(으!)


// STL을 이해하는데 있어 기본적인 4가지
// 1. 컨테이너 데이터를 담는 클래스 템플릿
// 2. 알고리즘 <algorithm> 자료의 탐색 정렬 검색 등을 담당하는 함수 템플릿
// 3. 함수객체 객체를 함수처럼 사용하는 문법 / 조건자 생성으로 사용
// 4. 반복자 iterator 포인터와 흡사한 동작을 하는 객체, 컨테이너 안의 원소를 순회하는 것이 목적

///////////////

// 1. 컨테이너
//		- 데이터를 저장하는 객체. 자료구조를 구현해서 제공하는 객체
//		- 클래스 템플릿의 형태
// 
//	  컨테이너 분류 기준
// 
//		1.1. 원소 배치 방식에 따른 구분
//			- 표준 시퀀스 컨테이너 : vector, list, deque | array, forward_list
//									방향성을 가지는(배열의 느낌) 컨테이너 선형적 컨테이너
//			- 표준 연관 컨테이너 : 방향성을 가지지 않는 (트리의 느낌) 컨테이너 비선형적 컨테이너
//					자동정렬하는 : set, multiset, map, multimap
//					정렬하지않는 : unordered_set, unordered_multiset, unordered_map, unordered_multimap
//
//		1.2. 메모리 저장 방식에 따른 구분
//			- 배열 기반 컨테이너 : vector, deque, array
//			- 노드 기반 컨테이너 : 

// 적기가 귀찮구나
// 그냥 수업자료를 받으렴

// 학원에서는 vector, list, map이 대부분


// 1. 컨테이너는 클래스 템플릿
// 2. 알고리즘은 함수 템플릿



// vector
// 임의 접근이 가능(동적배열기반이라) 탐색에 용이
// 반개 (반만 열린) 배열 방식
// 시작부분은 항상 0번째 인덱스고 뒤는 추가될 수 있음
// [begin, end)
// 탐색이 O(1)인데 비해 삽입 삭제가 O(n) 및 재할당이 걸려서 아쉽다
// 삭제할 땐 재할당 안함(당연함 또 넣으면.. 또 재할당하라고? ㅈㄴ손해다)


// list
// 노드 : 데이터를 저장하는 메모리 블럭
// (싱글)링크드리스트(단방향 연결), 환형 링크드리스트(원형 단방향 연결), 더블 링크드리스트(양방향 연결)
// list 는 더블링크드리스트, forward_list는 일반 단방향 링크드리스트(나중에 나옴)
// 맨 앞을 가리키는 헤드노드 또는 더미노드 라는 것이 존재함? 할수도있음? 무조건있는건아닌가? 보통있음
// 삽입 삭제가 진짜 개 편하다. O(1)임 대신 당연히 탐색이 O(n)이 되어버림(주소 참조로 돌아다녀서 무조건 한칸씩 이동해야하니까)

// deque
// 앞뒤로 삽입이 가능한 배열
// 실제로 쭈루룩 잇는 배열은 아니고 
// 리스트처럼 여러개의 청크 배열들이 연결된 구조와 비슷...
// vector가 못하는 앞 삽입이 아주 편하지만 대신 중간 삽입삭제가 vector보다 못함
// 42때 왜 데크 얘기가 나왔더라?
// 데크도 대괄호연산자가 가능하고 그렇기 때문에 벡터처럼 임의접근이 가능~

// array(C++11)
// 진짜 걍 배열... 의 STL컨테이너 버전
// 비슷하다. 대신 객체지향이라던지, 반복자사용이라던지, 그런 용도를 위해서 재정의되었다 보는 느낌
// vector와 비교:
//		정해진 크기의 데이터를 관리할 땐 array가 낫다(vector는 언제 추가될 지 모르니 넉넉히 잡아서)
//		당연하지만 추가할 예정이 있으면 array는 불가능(원래 배열도 안되니까)
//		용량 면도 vector가 더 크긴 하다

// forward_list(C++11)
// 단방향 링크드 리스트
// 보통의 링크드 리스트를 생각하면 원래 이거
// 데이터를 추가할 땐 앞에다 추가한다
//	맨 뒤에 추가하려면 뭐가됐든 리스트는 헤드노드를 통해 시작해야하는데 끝까지 참조해서 들어가서 거기다 링크해야하기때문
//	너무귀찮다. 그냥 앞에 넣으면 헤드가 참조하는 주소 건네주기만 하면 되는데...
// 역방향을 사실 잘 안쓰긴 해서 그럴거면 용량이 적고 효율적인 싱글LL이 낫지 않겠냐 해서 나온게 forward_list
// 당연하지만 ... 귀찮아서 list를 쓰게 된다(그리고 혹시!!라는 상황이 주는 어떤..그런거.)


int main()
{

}
