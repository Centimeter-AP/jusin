#include "pch.h"

int main()
{
	// 반복자(iterator)
	// 포인터랑 비슷한 동작을 함

	vector<int>	vecTemp;

	vecTemp.push_back(10);
	vecTemp.push_back(20);

	vector<int>::iterator	iter = vecTemp.begin();		// 보통 처음 위치로 초기화함
	// begin()은 맨 처음 원소를 가리키는게 아니라 맨 처음 원소의 위치!!를 가리키는 반복자 상태임.
	// 그래서 포인터와 비슷하다고 하는 것. (그러나 반복자는 실제 주소를 가리키는 것 자체는 아님)
	// 포인터와 비슷한 동작을 위해 * 연산자 오버로딩이 되어있음
	cout << *iter << endl;
	// 첫번째 원소를 가리키는 공간.... 안에 참조! 를 하니까 그제야 안의 원소 값을 볼 수 있음.

	// 1. 출력 반복자
	//	- 컨테이너 내의 원소 읽기만 가능한 반복자 (*)
	// 2. 입력 반복자
	//	- 읽기, 쓰기 모두 가능한 반복자 (*, =)
	// 3. 정방향(순방향) 반복자
	//  - 읽기, 쓰기가 가능하고 정방향으로 이동해 접근이 가능한 반복자 (*, =, ++)
	// 4. 양방향 반복자 **
	//  - 읽기, 쓰기, 정방향 및 역방향 이동 및 접근이 가능한 반복자 (*, =, ++, --)
	// 5. 임의접근 반복자 **
	//	- 전부 되며 원소의 임의 접근을 허용함 (*, =, ++, --, +=, -=)(대괄호연산자는안되고)

	// 임의접근이 가능한 컨테이너들은 임의접근 반복자
	// 노드 기반인 애들은 양방향 접근자를 사용
	// forward_list만 정방향 반복자 사용

	vector<int>::iterator	it = vecTemp.begin() + 1;		
	// begin() + 1이 되는 것 자체가 임의접근반복자가 가능하다는 뜻(쁠마연산자가 오버로딩되어있음)
	// 당연히 list같은 노드 기반 컨테이너인 양방향 반복자는 + 사용이 불가능함

	
	// 다시 멤버함수타임

	vecTemp.insert(iter, 400);		//iter가 위치한 곳에 중간 삽입
	
	iter = vecTemp.erase(iter);		//iter가 위치한 곳의 원소를 삭제
	// erase()는 반환타입이 반복자이고 삭제된 곳을 iter가 가리키고 있으면 안되기 때문에
	// 반환타입을 받아서 iter가 가리키는 곳을 변경해주면 안전






	return 0;
}