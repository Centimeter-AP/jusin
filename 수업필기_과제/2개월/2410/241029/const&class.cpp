#include <iostream>

// const 라는 키워드는 예민하게 쓰겠다는 의미가 있음
// 불편하고, 고정적이고, 변하지 않게 만들겠다는 것이 실제 const의 의의
// 그런데 그때 mutable이 나타났다.............

// 클래스 내부에 const를 덕지덕지 붙여보기
//
// 1. 멤버 변수에 const(리터럴 상수) 붙이고 이니셜라이저로 초기화하기
// 2. 멤버 함수에 const를 뒤에 붙여서 읽기전용함수로 만들기
// 	- 멤버 변수의 쓰기를 허용하지 않음 (읽는건 알빠x)
//  - 지역변수, 전역변수 등 멤버 변수가 아닌 애들의 읽쓰 또한 알빠x
//  - 읽기전용함수 내부에서 읽기전용이 아닌 함수를 호출 할 수 없음 (그 함수가 쓰기 할 지 어케알음??)
// 3. const 키워드로 읽기전용 오버로딩이 가능하다...
//  - class 또한 const로 생성되어서 읽기전용 클래스가 되었을 때 동일 명칭의 함수여도 const 붙은 함수가 실행됨
//  - 당연히 const가 없는 class로 생성되었을 땐 const 없는 함수가 실행됨.
// 




using namespace std;

class CObj
{
private:
	const int m_iA;		// const로 상수를 선언하면
public:
	CObj();
	// {
	// m_iA = 100;		// 생성자 내부에서 대입으로 초기화 하는것이 불가능
	// }				// 사실 당연함 이건 초기화가 아니라 초기화 처럼 보이는 대입연산자임

	CObj(int _iA) : m_iA(10)	// 이니셜라이저 라는 실제 초기화 문법을 이용해 초기화함
	{}
};





int main()
{
	
	return 0;
}
